<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python面试常见问题及解答</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#64748b',
                        accent: '#10b981',
                        dark: '#1e293b',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .question-card {
                @apply bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow duration-300 mb-4 overflow-hidden;
            }
            .question-header {
                @apply bg-primary/5 px-6 py-4 cursor-pointer flex justify-between items-center;
            }
            .answer-content {
                @apply px-6 py-4 bg-white border-t border-gray-100 text-secondary space-y-2;
            }
            .code-block {
                @apply bg-gray-900 text-gray-100 p-4 rounded-md overflow-x-auto font-mono text-sm my-2;
            }
            .tag {
                @apply inline-block px-2 py-1 text-xs rounded-full bg-primary/10 text-primary mr-2 mb-2;
            }
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <!-- 顶部导航 -->
    <header class="bg-white shadow-sm sticky top-0 z-10">
        <div class="container mx-auto px-4 py-4 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-primary">
                <i class="fa fa-python mr-2"></i>Python面试宝典
            </h1>
            <nav>
                <ul class="flex space-x-6">
                    <li><a href="#basic" class="text-secondary hover:text-primary transition-colors">基础语法</a></li>
                    <li><a href="#data-structure" class="text-secondary hover:text-primary transition-colors">数据结构</a></li>
                    <li><a href="#oop" class="text-secondary hover:text-primary transition-colors">面向对象</a></li>
                    <li><a href="#advanced" class="text-secondary hover:text-primary transition-colors">高级特性</a></li>
                    <li><a href="#performance" class="text-secondary hover:text-primary transition-colors">性能优化</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- 主内容区 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 介绍部分 -->
        <section class="mb-12 text-center">
            <h2 class="text-3xl font-bold text-dark mb-4">Python面试常见问题及解答</h2>
            <p class="text-secondary max-w-3xl mx-auto">覆盖Python基础、进阶、高级特性等核心考点，助力面试准备</p>
        </section>

        <!-- 基础语法部分 -->
        <section id="basic" class="mb-12">
            <h3 class="text-2xl font-bold text-dark mb-6 border-b border-gray-200 pb-2">
                <i class="fa fa-code mr-2 text-primary"></i>基础语法
            </h3>

            <!-- 问题1 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">1. Python中的可变类型和不可变类型有哪些？区别是什么？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>不可变类型：</strong>数值类型（int、float、bool）、字符串（str）、元组（tuple）、冻结集合（frozenset）</p>
                    <p><strong>可变类型：</strong>列表（list）、字典（dict）、集合（set）</p>
                    <p><strong>核心区别：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>不可变类型：内存中的值不可修改，修改时会创建新对象，原对象地址不变</li>
                        <li>可变类型：内存中的值可以直接修改，对象地址保持不变</li>
                    </ul>
                    <div class="code-block">
                        # 不可变类型示例
                        a = 1
                        print(id(a))  # 输出内存地址
                        a += 1
                        print(id(a))  # 地址变化，创建了新对象

                        # 可变类型示例
                        lst = [1, 2, 3]
                        print(id(lst))  # 输出内存地址
                        lst.append(4)
                        print(id(lst))  # 地址不变
                    </div>
                    <div class="tags">
                        <span class="tag">基础类型</span>
                        <span class="tag">内存管理</span>
                    </div>
                </div>
            </div>

            <!-- 问题2 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">2. Python中的is和==的区别？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>==：</strong>比较两个对象的值是否相等（值比较）</p>
                    <p><strong>is：</strong>比较两个对象的内存地址是否相同（身份比较），即是否是同一个对象</p>
                    <div class="code-block">
                        a = [1, 2, 3]
                        b = [1, 2, 3]
                        c = a

                        print(a == b)  # True，值相等
                        print(a is b)  # False，不同对象
                        print(a is c)  # True，同一个对象

                        # 小整数池特殊情况
                        x = 10
                        y = 10
                        print(x is y)  # True，小整数池缓存

                        x = 257
                        y = 257
                        print(x is y)  # False，超出小整数池范围
                    </div>
                    <div class="tags">
                        <span class="tag">运算符</span>
                        <span class="tag">内存地址</span>
                    </div>
                </div>
            </div>

            <!-- 问题3 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">3. Python中的装饰器是什么？如何实现？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>装饰器：</strong>一种特殊的函数，用于修改其他函数的功能，不修改原函数代码，遵循开放封闭原则</p>
                    <p><strong>实现原理：</strong>基于函数嵌套和闭包，返回值为函数对象</p>
                    <div class="code-block">
                        # 基础装饰器示例
                        def logger(func):
                            def wrapper(*args, **kwargs):
                                print(f"调用函数：{func.__name__}")
                                result = func(*args, **kwargs)
                                print(f"函数执行完成：{func.__name__}")
                                return result
                            return wrapper

                        @logger  # 等价于 add = logger(add)
                        def add(a, b):
                            return a + b

                        print(add(2, 3))  # 输出日志并返回5

                        # 带参数的装饰器
                        def logger_with_level(level):
                            def decorator(func):
                                def wrapper(*args, **kwargs):
                                    print(f"[{level}] 调用函数：{func.__name__}")
                                    return func(*args, **kwargs)
                                return wrapper
                            return decorator

                        @logger_with_level("INFO")
                        def subtract(a, b):
                            return a - b
                    </div>
                    <div class="tags">
                        <span class="tag">装饰器</span>
                        <span class="tag">闭包</span>
                        <span class="tag">函数式编程</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 数据结构部分 -->
        <section id="data-structure" class="mb-12">
            <h3 class="text-2xl font-bold text-dark mb-6 border-b border-gray-200 pb-2">
                <i class="fa fa-sitemap mr-2 text-primary"></i>数据结构
            </h3>

            <!-- 问题1 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">1. 列表和元组的区别？各自的使用场景？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>语法区别：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>列表用[]定义，元组用()定义</li>
                        <li>列表是可变类型，元组是不可变类型</li>
                        <li>元组支持解包，列表也支持但元组更常用</li>
                        <li>元组可作为字典的key，列表不行</li>
                    </ul>
                    <p><strong>性能区别：</strong>元组创建和访问速度更快，占用内存更少</p>
                    <p><strong>使用场景：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>列表：需要频繁修改的数据集合（如动态添加/删除元素）</li>
                        <li>元组：数据不可变的场景（如配置项、函数返回多个值、字典的key）</li>
                    </ul>
                    <div class="code-block">
                        # 元组作为字典key
                        dict_with_tuple_key = {('a', 'b'): 123}
                        # dict_with_list_key = {['a', 'b']: 123}  # 报错

                        # 函数返回多个值（本质是元组）
                        def get_user():
                            return "张三", 25, "男"
                        name, age, gender = get_user()  # 元组解包
                    </div>
                    <div class="tags">
                        <span class="tag">列表</span>
                        <span class="tag">元组</span>
                        <span class="tag">性能</span>
                    </div>
                </div>
            </div>

            <!-- 问题2 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">2. 字典的底层实现原理？如何解决哈希冲突？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>底层实现：</strong>Python3.7+字典基于哈希表（开放地址法）实现，核心是数组+链表/红黑树</p>
                    <p><strong>实现步骤：</strong></p>
                    <ol class="list-decimal pl-5 space-y-1">
                        <li>对key进行哈希计算，得到哈希值</li>
                        <li>通过哈希值取模得到数组索引位置</li>
                        <li>将key-value存储到对应位置</li>
                        <li>发生哈希冲突时，使用开放地址法（线性探测、二次探测）解决</li>
                    </ol>
                    <p><strong>哈希冲突解决：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>开放地址法：冲突时寻找下一个空的槽位</li>
                        <li>Python采用伪随机探测（pseudo-random probing）</li>
                        <li>当负载因子超过阈值（默认0.66）时，进行扩容（2倍）</li>
                    </ul>
                    <p><strong>注意事项：</strong>字典的key必须是不可变类型（可哈希）</p>
                    <div class="tags">
                        <span class="tag">字典</span>
                        <span class="tag">哈希表</span>
                        <span class="tag">底层原理</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 面向对象部分 -->
        <section id="oop" class="mb-12">
            <h3 class="text-2xl font-bold text-dark mb-6 border-b border-gray-200 pb-2">
                <i class="fa fa-object-group mr-2 text-primary"></i>面向对象
            </h3>

            <!-- 问题1 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">1. Python中的继承方式？MRO（方法解析顺序）是什么？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>继承方式：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>单继承：子类继承一个父类</li>
                        <li>多继承：子类继承多个父类</li>
                        <li>多层继承：子类继承父类，父类又继承其他类</li>
                    </ul>
                    <p><strong>MRO（Method Resolution Order）：</strong>方法解析顺序，解决多继承时的属性查找顺序问题</p>
                    <p><strong>Python MRO规则：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>采用C3线性化算法，而非简单的深度优先</li>
                        <li>保证子类先于父类被检查</li>
                        <li>保证父类的顺序与声明顺序一致</li>
                        <li>保证如果一个类继承多个类，这些类的MRO保持一致</li>
                    </ul>
                    <div class="code-block">
                        class A: pass
                        class B(A): pass
                        class C(A): pass
                        class D(B, C): pass

                        print(D.mro())  # 输出: [D, B, C, A, object]
                        # 或使用 __mro__ 属性
                        print(D.__mro__)
                    </div>
                    <div class="tags">
                        <span class="tag">继承</span>
                        <span class="tag">MRO</span>
                        <span class="tag">面向对象</span>
                    </div>
                </div>
            </div>

            <!-- 问题2 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">2. 什么是装饰器模式？与Python装饰器的区别？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>装饰器模式（设计模式）：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>一种结构型设计模式，动态地给对象添加额外功能</li>
                        <li>遵循开放封闭原则，不修改原对象代码</li>
                        <li>通过组合而非继承实现功能扩展</li>
                    </ul>
                    <p><strong>Python装饰器：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>Python语言特性，主要用于装饰函数/方法</li>
                        <li>基于闭包实现，语法上使用@符号</li>
                        <li>本质是装饰器模式的一种语言级实现</li>
                    </ul>
                    <div class="code-block">
                        # 装饰器模式实现
                        class Component:
                            def operation(self):
                                pass

                        class ConcreteComponent(Component):
                            def operation(self):
                                return "基础功能"

                        class Decorator(Component):
                            def __init__(self, component):
                                self._component = component
                            def operation(self):
                                return self._component.operation()

                        class LoggingDecorator(Decorator):
                            def operation(self):
                                print("记录日志")
                                return f"{self._component.operation()} + 日志功能"

                        # 使用
                        component = ConcreteComponent()
                        decorated = LoggingDecorator(component)
                        print(decorated.operation())
                    </div>
                    <div class="tags">
                        <span class="tag">设计模式</span>
                        <span class="tag">装饰器模式</span>
                        <span class="tag">面向对象</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 高级特性部分 -->
        <section id="advanced" class="mb-12">
            <h3 class="text-2xl font-bold text-dark mb-6 border-b border-gray-200 pb-2">
                <i class="fa fa-rocket mr-2 text-primary"></i>高级特性
            </h3>

            <!-- 问题1 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">1. 什么是生成器（Generator）？与迭代器的区别？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>迭代器（Iterator）：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>实现了__iter__()和__next__()方法的对象</li>
                        <li>可以通过next()函数逐个获取元素</li>
                        <li>遍历完抛出StopIteration异常</li>
                    </ul>
                    <p><strong>生成器（Generator）：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>特殊的迭代器，简化了迭代器的实现</li>
                        <li>使用yield关键字定义，函数执行到yield暂停并返回值</li>
                        <li>分为生成器函数和生成器表达式</li>
                        <li>惰性求值，节省内存</li>
                    </ul>
                    <div class="code-block">
                        # 生成器函数
                        def fibonacci(n):
                            a, b = 0, 1
                            for _ in range(n):
                                yield a
                                a, b = b, a + b

                        # 使用生成器
                        fib = fibonacci(5)
                        print(next(fib))  # 0
                        print(next(fib))  # 1

                        # 生成器表达式
                        gen_expr = (x * x for x in range(10))
                        print(list(gen_expr))  # [0,1,4,...,81]

                        # 迭代器示例
                        lst = [1,2,3]
                        it = iter(lst)
                        print(next(it))  # 1
                    </div>
                    <div class="tags">
                        <span class="tag">生成器</span>
                        <span class="tag">迭代器</span>
                        <span class="tag">惰性求值</span>
                    </div>
                </div>
            </div>

            <!-- 问题2 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">2. Python中的GIL（全局解释器锁）是什么？影响是什么？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>GIL定义：</strong>Python解释器（CPython）中的全局锁，保证同一时刻只有一个线程执行Python字节码</p>
                    <p><strong>设计目的：</strong>简化CPython的内存管理，避免多线程竞争资源</p>
                    <p><strong>主要影响：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>Python的多线程在CPU密集型任务中无法利用多核优势</li>
                        <li>IO密集型任务（如网络请求、文件IO）中多线程仍有优势（等待时释放GIL）</li>
                        <li>多进程可以绕过GIL（每个进程有独立的Python解释器和GIL）</li>
                    </ul>
                    <p><strong>解决方案：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>CPU密集型：使用multiprocessing多进程</li>
                        <li>IO密集型：使用多线程或异步编程（asyncio）</li>
                        <li>使用其他Python解释器（如Jython、IronPython无GIL）</li>
                    </ul>
                    <div class="code-block">
                        # 多进程示例（CPU密集型）
                        from multiprocessing import Pool
                        import time

                        def compute(x):
                            return x * x

                        if __name__ == "__main__":
                            start = time.time()
                            with Pool(4) as pool:
                                result = pool.map(compute, range(1000000))
                            print(f"耗时: {time.time() - start:.2f}秒")
                    </div>
                    <div class="tags">
                        <span class="tag">GIL</span>
                        <span class="tag">多线程</span>
                        <span class="tag">并发编程</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 性能优化部分 -->
        <section id="performance" class="mb-12">
            <h3 class="text-2xl font-bold text-dark mb-6 border-b border-gray-200 pb-2">
                <i class="fa fa-tachometer mr-2 text-primary"></i>性能优化
            </h3>

            <!-- 问题1 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">1. 如何优化Python程序的性能？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>代码层面优化：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>使用内置函数和标准库（如map、filter、itertools）替代手动循环</li>
                        <li>使用生成器替代列表（减少内存占用）</li>
                        <li>避免频繁的字符串拼接（使用join()）</li>
                        <li>使用集合（set）进行成员判断（O(1)时间复杂度）</li>
                    </ul>
                    <p><strong>算法层面优化：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>选择合适的数据结构（如字典替代列表查找）</li>
                        <li>减少时间复杂度（如O(n²)→O(n log n)）</li>
                        <li>缓存计算结果（lru_cache装饰器）</li>
                    </ul>
                    <p><strong>技术层面优化：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>CPU密集型：使用多进程或C扩展（Cython、PyPy）</li>
                        <li>IO密集型：使用异步编程（asyncio）或多线程</li>
                        <li>使用性能分析工具（cProfile、line_profiler）定位瓶颈</li>
                    </ul>
                    <div class="code-block">
                        # 使用lru_cache缓存
                        from functools import lru_cache

                        @lru_cache(maxsize=None)
                        def fib(n):
                            if n <= 1:
                                return n
                            return fib(n-1) + fib(n-2)

                        # 字符串拼接优化
                        # 低效
                        s = ""
                        for i in range(1000):
                            s += str(i)

                        # 高效
                        parts = []
                        for i in range(1000):
                            parts.append(str(i))
                        s = "".join(parts)
                    </div>
                    <div class="tags">
                        <span class="tag">性能优化</span>
                        <span class="tag">算法</span>
                        <span class="tag">缓存</span>
                    </div>
                </div>
            </div>

            <!-- 问题2 -->
            <div class="question-card">
                <div class="question-header" onclick="toggleAnswer(this)">
                    <h4 class="font-semibold text-lg">2. 什么是内存泄漏？Python中如何检测和避免？</h4>
                    <i class="fa fa-chevron-down text-primary transition-transform duration-300"></i>
                </div>
                <div class="answer-content hidden">
                    <p><strong>内存泄漏：</strong>程序中已分配的内存不再使用，但未被释放，导致内存占用持续增加</p>
                    <p><strong>Python中内存泄漏的常见原因：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>全局变量持有大量对象引用</li>
                        <li>循环引用（Python的垃圾回收可处理，但仍可能有问题）</li>
                        <li>未关闭的文件/网络连接/数据库连接</li>
                        <li>缓存未设置过期策略</li>
                        <li>C扩展模块的内存管理不当</li>
                    </ul>
                    <p><strong>检测工具：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>tracemalloc：Python3.4+内置的内存分析工具</li>
                        <li>objgraph：可视化对象引用关系</li>
                        <li>memory_profiler：逐行分析内存使用</li>
                    </ul>
                    <p><strong>避免方法：</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>尽量避免全局变量</li>
                        <li>使用with语句自动释放资源</li>
                        <li>设置缓存的最大大小和过期时间</li>
                        <li>定期手动触发垃圾回收（gc.collect()）</li>
                        <li>使用弱引用（weakref）避免强引用</li>
                    </ul>
                    <div class="code-block">
                        # 使用tracemalloc检测内存泄漏
                        import tracemalloc

                        tracemalloc.start()

                        # 执行可能泄漏的代码
                        lst = []
                        for i in range(100000):
                            lst.append(" " * 1000)

                        snapshot = tracemalloc.take_snapshot()
                        top_stats = snapshot.statistics('lineno')

                        print("[ Top 10 ]")
                        for stat in top_stats[:10]:
                            print(stat)
                    </div>
                    <div class="tags">
                        <span class="tag">内存泄漏</span>
                        <span class="tag">垃圾回收</span>
                        <span class="tag">内存管理</span>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- 页脚 -->
    <footer class="bg-dark text-white py-8">
        <div class="container mx-auto px-4 text-center">
            <p class="mb-2">Python面试宝典 © 2025</p>
            <p class="text-gray-400 text-sm">覆盖Python核心面试考点，持续更新中</p>
        </div>
    </footer>

    <script>
        // 切换答案显示/隐藏
        function toggleAnswer(element) {
            const answer = element.nextElementSibling;
            const icon = element.querySelector('i');
            
            answer.classList.toggle('hidden');
            icon.classList.toggle('rotate-180');
        }

        // 页面加载时展开第一个问题
        document.addEventListener('DOMContentLoaded', function() {
            const firstQuestion = document.querySelector('.question-header');
            if (firstQuestion) {
                toggleAnswer(firstQuestion);
            }

            // 平滑滚动
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetElement = document.querySelector(targetId);
                    if (targetElement) {
                        targetElement.scrollIntoView({
                            behavior: 'smooth'
                        });
                    }
                });
            });
        });
    </script>
</body>
</html>